package info.ata4.minecraft.dragon.server.entity.helper.breath;

import info.ata4.minecraft.dragon.util.Pair;
import net.minecraft.block.Block;
import net.minecraft.block.BlockFence;
import net.minecraft.block.BlockFenceGate;
import net.minecraft.block.BlockWall;
import net.minecraft.block.material.Material;
import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.util.*;
import net.minecraft.world.World;

import javax.sound.sampled.Line;
import java.util.*;

/**
* Created by TGG on 30/07/2015.
* BreathAffectedArea base class
- generated by BreedHelper
- stores the area of effect; called every tick with the breathing direction; applies the effects of the breath weapon
- derived classes for each type of breath
Ctor
- update (not breathing) or update(start, finish)
- affectBlock for each block
- affectEntity for each entity
*/
public abstract class BreathAffectedArea
{

  public void updateTickBreathing(Vec3 origin, Vec3 destination) {

  }

  public void updateTickNotBreathing() {

  }


  private void drawBreathNode(HashSet<BlockPos> blocksInBeam, HashSet<Integer> entitiesInBeam, Vec3 origin, Vec3 direction, float distance)
  {

  }

  private void moveNode()
  {

  }

  private void compileAffected(World world, Map<LineSegment, BreathNode> breathNodes,
                               HashMap<Vec3i, Float> affectedBlocks, HashMap<Integer, Float> affectedEntities)
  {
    if (breathNodes.isEmpty()) return;

    ArrayList<LineSegment> lineSegments = new ArrayList<LineSegment>(breathNodes.keySet());
    ArrayList<LineSegment> xLowSorted = LineSegment.deepCopy(lineSegments);
    LineSegment.sort(xLowSorted, LineSegment.SortOrder.X_LOW);

    ArrayList<LineSegment> xHighSorted = LineSegment.deepCopy(xLowSorted);
    LineSegment.sort(xHighSorted, LineSegment.SortOrder.X_HIGH);

    ArrayList<LineSegment> yLowSorted = LineSegment.deepCopy(xHighSorted);
    LineSegment.sort(yLowSorted, LineSegment.SortOrder.Y_LOW);

    ArrayList<LineSegment> yHighSorted = LineSegment.deepCopy(yLowSorted);
    LineSegment.sort(yHighSorted, LineSegment.SortOrder.Y_HIGH);

    ArrayList<LineSegment> zLowSorted = LineSegment.deepCopy(yHighSorted);
    LineSegment.sort(zLowSorted, LineSegment.SortOrder.Z_LOW);

    ArrayList<LineSegment> zHighSorted = LineSegment.deepCopy(zLowSorted);
    LineSegment.sort(zHighSorted, LineSegment.SortOrder.Z_HIGH);

    final int NUMBER_OF_CLOUD_POINTS = 10;
    for (Map.Entry<LineSegment, BreathNode> segment : breathNodes.entrySet()) {
      float radius = segment.getValue().getCurrentSize();
      float intensity = segment.getValue().getCurrentIntensity();
      segment.getKey().addStochasticCloud(affectedBlocks, radius, intensity, NUMBER_OF_CLOUD_POINTS);
    }

    int segmentCount = lineSegments.size();
    double xMin = xLowSorted.get(0).smallerPoint.xCoord;
    double xMax = xHighSorted.get(segmentCount-1).largerPoint.xCoord;
    double yMin = yLowSorted.get(0).smallerPoint.yCoord;
    double yMax = yHighSorted.get(segmentCount-1).largerPoint.yCoord;
    double zMin = zLowSorted.get(0).smallerPoint.zCoord;
    double zMax = zHighSorted.get(segmentCount-1).largerPoint.zCoord;

    AxisAlignedBB allAABB = new AxisAlignedBB(xMin, yMin, zMin, xMax, yMax, zMax);
    List<EntityLivingBase> allEntities = world.getEntitiesWithinAABB(EntityLivingBase.class, allAABB);

    for (EntityLivingBase entityLivingBase : allEntities) {

    }

  }
  private HashSet<BlockPos>;
  private HashSet<Integer>;

  private LinkedList<EntityBreathNodeServer> breathNodes;



}
