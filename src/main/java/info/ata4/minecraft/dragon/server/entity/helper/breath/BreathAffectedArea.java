//package info.ata4.minecraft.dragon.server.entity.helper.breath;
//
//import net.minecraft.block.Block;
//import net.minecraft.block.BlockFence;
//import net.minecraft.block.BlockFenceGate;
//import net.minecraft.block.BlockWall;
//import net.minecraft.block.material.Material;
//import net.minecraft.crash.CrashReport;
//import net.minecraft.crash.CrashReportCategory;
//import net.minecraft.entity.player.EntityPlayer;
//import net.minecraft.init.Blocks;
//import net.minecraft.util.*;
//
//import java.util.HashSet;
//import java.util.Iterator;
//import java.util.LinkedList;
//import java.util.List;
//
///**
// * Created by TGG on 30/07/2015.
// * BreathAffectedArea base class
// - generated by BreedHelper
// - stores the area of effect; called every tick with the breathing direction; applies the effects of the breath weapon
// - derived classes for each type of breath
// Ctor
// - update (not breathing) or update(start, finish)
// - affectBlock for each block
// - affectEntity for each entity
// */
//public abstract class BreathAffectedArea
//{
//
//  public void updateTickBreathing(Vec3 origin, Vec3 destination) {
//
//  }
//
//  public void updateTickNotBreathing() {
//
//  }
//
//
//  private void drawBreathNode(HashSet<BlockPos> blocksInBeam, HashSet<Integer> entitiesInBeam, Vec3 origin, Vec3 direction, float distance)
//  {
//
//
//    size
//
//    final float PARTIAL_TICK = 1.0F;
//    Vec3 positionEyes = entityPlayerSP.getPositionEyes(PARTIAL_TICK);
//    Vec3 lookDirection = entityPlayerSP.getLook(PARTIAL_TICK);
//    Vec3 endOfLook = positionEyes.addVector(lookDirection.xCoord * maxDistance,
//            lookDirection.yCoord * maxDistance,
//            lookDirection.zCoord * maxDistance);
//    final boolean STOP_ON_LIQUID = true;
//    final boolean IGNORE_BOUNDING_BOX = false;
//    final boolean RETURN_NULL_IF_NO_COLLIDE = true;
//    MovingObjectPosition targetedBlock = world.rayTraceBlocks(positionEyes, endOfLook,
//            STOP_ON_LIQUID, IGNORE_BOUNDING_BOX,
//            !RETURN_NULL_IF_NO_COLLIDE);
//
//  }
//
//  private void moveNode()
//  {
//
//
//  }
//
//  private dummy() {
//    public void moveEntity(double x, double y, double z)
//    {
//        double d3 = this.posX;
//        double d4 = this.posY;
//        double d5 = this.posZ;
//
//        double d6 = x;
//        double d7 = y;
//        double d8 = z;
//        List list1 = this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().addCoord(x, y, z));
//        AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
//        AxisAlignedBB axisalignedbb1;
//
//        for (Iterator iterator = list1.iterator(); iterator.hasNext(); y = axisalignedbb1.calculateYOffset(this.getEntityBoundingBox(), y))
//        {
//          axisalignedbb1 = (AxisAlignedBB)iterator.next();
//        }
//
//        this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, y, 0.0D));
//        boolean flag1 = this.onGround || d7 != y && d7 < 0.0D;
//        AxisAlignedBB axisalignedbb2;
//        Iterator iterator8;
//
//        for (iterator8 = list1.iterator(); iterator8.hasNext(); x = axisalignedbb2.calculateXOffset(this.getEntityBoundingBox(), x))
//        {
//          axisalignedbb2 = (AxisAlignedBB)iterator8.next();
//        }
//
//        this.setEntityBoundingBox(this.getEntityBoundingBox().offset(x, 0.0D, 0.0D));
//
//        for (iterator8 = list1.iterator(); iterator8.hasNext(); z = axisalignedbb2.calculateZOffset(this.getEntityBoundingBox(), z))
//        {
//          axisalignedbb2 = (AxisAlignedBB)iterator8.next();
//        }
//
//        this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, 0.0D, z));
//
//        if (this.stepHeight > 0.0F && flag1 && (d6 != x || d8 != z))
//        {
//          double d14 = x;
//          double d10 = y;
//          double d11 = z;
//          AxisAlignedBB axisalignedbb3 = this.getEntityBoundingBox();
//          this.setEntityBoundingBox(axisalignedbb);
//          y = (double)this.stepHeight;
//          List list = this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().addCoord(d6, y, d8));
//          AxisAlignedBB axisalignedbb4 = this.getEntityBoundingBox();
//          AxisAlignedBB axisalignedbb5 = axisalignedbb4.addCoord(d6, 0.0D, d8);
//          double d12 = y;
//          AxisAlignedBB axisalignedbb6;
//
//          for (Iterator iterator1 = list.iterator(); iterator1.hasNext(); d12 = axisalignedbb6.calculateYOffset(axisalignedbb5, d12))
//          {
//            axisalignedbb6 = (AxisAlignedBB)iterator1.next();
//          }
//
//          axisalignedbb4 = axisalignedbb4.offset(0.0D, d12, 0.0D);
//          double d18 = d6;
//          AxisAlignedBB axisalignedbb7;
//
//          for (Iterator iterator2 = list.iterator(); iterator2.hasNext(); d18 = axisalignedbb7.calculateXOffset(axisalignedbb4, d18))
//          {
//            axisalignedbb7 = (AxisAlignedBB)iterator2.next();
//          }
//
//          axisalignedbb4 = axisalignedbb4.offset(d18, 0.0D, 0.0D);
//          double d19 = d8;
//          AxisAlignedBB axisalignedbb8;
//
//          for (Iterator iterator3 = list.iterator(); iterator3.hasNext(); d19 = axisalignedbb8.calculateZOffset(axisalignedbb4, d19))
//          {
//            axisalignedbb8 = (AxisAlignedBB)iterator3.next();
//          }
//
//          axisalignedbb4 = axisalignedbb4.offset(0.0D, 0.0D, d19);
//          AxisAlignedBB axisalignedbb13 = this.getEntityBoundingBox();
//          double d20 = y;
//          AxisAlignedBB axisalignedbb9;
//
//          for (Iterator iterator4 = list.iterator(); iterator4.hasNext(); d20 = axisalignedbb9.calculateYOffset(axisalignedbb13, d20))
//          {
//            axisalignedbb9 = (AxisAlignedBB)iterator4.next();
//          }
//
//          axisalignedbb13 = axisalignedbb13.offset(0.0D, d20, 0.0D);
//          double d21 = d6;
//          AxisAlignedBB axisalignedbb10;
//
//          for (Iterator iterator5 = list.iterator(); iterator5.hasNext(); d21 = axisalignedbb10.calculateXOffset(axisalignedbb13, d21))
//          {
//            axisalignedbb10 = (AxisAlignedBB)iterator5.next();
//          }
//
//          axisalignedbb13 = axisalignedbb13.offset(d21, 0.0D, 0.0D);
//          double d22 = d8;
//          AxisAlignedBB axisalignedbb11;
//
//          for (Iterator iterator6 = list.iterator(); iterator6.hasNext(); d22 = axisalignedbb11.calculateZOffset(axisalignedbb13, d22))
//          {
//            axisalignedbb11 = (AxisAlignedBB)iterator6.next();
//          }
//
//          axisalignedbb13 = axisalignedbb13.offset(0.0D, 0.0D, d22);
//          double d23 = d18 * d18 + d19 * d19;
//          double d13 = d21 * d21 + d22 * d22;
//
//          if (d23 > d13)
//          {
//            x = d18;
//            z = d19;
//            this.setEntityBoundingBox(axisalignedbb4);
//          }
//          else
//          {
//            x = d21;
//            z = d22;
//            this.setEntityBoundingBox(axisalignedbb13);
//          }
//
//          y = (double)(-this.stepHeight);
//          AxisAlignedBB axisalignedbb12;
//
//          for (Iterator iterator7 = list.iterator(); iterator7.hasNext(); y = axisalignedbb12.calculateYOffset(this.getEntityBoundingBox(), y))
//          {
//            axisalignedbb12 = (AxisAlignedBB)iterator7.next();
//          }
//
//          this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, y, 0.0D));
//
//          if (d14 * d14 + d11 * d11 >= x * x + z * z)
//          {
//            x = d14;
//            y = d10;
//            z = d11;
//            this.setEntityBoundingBox(axisalignedbb3);
//          }
//        }
//
//        this.worldObj.theProfiler.endSection();
//        this.worldObj.theProfiler.startSection("rest");
//        this.resetPositionToBB();
//        this.isCollidedHorizontally = d6 != x || d8 != z;
//        this.isCollidedVertically = d7 != y;
//        this.onGround = this.isCollidedVertically && d7 < 0.0D;
//        this.isCollided = this.isCollidedHorizontally || this.isCollidedVertically;
//        int i = MathHelper.floor_double(this.posX);
//        int j = MathHelper.floor_double(this.posY - 0.20000000298023224D);
//        int k = MathHelper.floor_double(this.posZ);
//        BlockPos blockpos = new BlockPos(i, j, k);
//        Block block1 = this.worldObj.getBlockState(blockpos).getBlock();
//
//        if (block1.getMaterial() == Material.air)
//        {
//          Block block = this.worldObj.getBlockState(blockpos.down()).getBlock();
//
//          if (block instanceof BlockFence || block instanceof BlockWall || block instanceof BlockFenceGate)
//          {
//            block1 = block;
//            blockpos = blockpos.down();
//          }
//        }
//
//        this.func_180433_a(y, this.onGround, block1, blockpos);
//
//        if (d6 != x)
//        {
//          this.motionX = 0.0D;
//        }
//
//        if (d8 != z)
//        {
//          this.motionZ = 0.0D;
//        }
//
//        if (d7 != y)
//        {
//          block1.onLanded(this.worldObj, this);
//        }
//
//        if (this.canTriggerWalking() && !flag && this.ridingEntity == null)
//        {
//          double d15 = this.posX - d3;
//          double d16 = this.posY - d4;
//          double d17 = this.posZ - d5;
//
//          if (block1 != Blocks.ladder)
//          {
//            d16 = 0.0D;
//          }
//
//          if (block1 != null && this.onGround)
//          {
//            block1.onEntityCollidedWithBlock(this.worldObj, blockpos, this);
//          }
//
//          this.distanceWalkedModified = (float)((double)this.distanceWalkedModified + (double)MathHelper.sqrt_double(d15 * d15 + d17 * d17) * 0.6D);
//          this.distanceWalkedOnStepModified = (float)((double)this.distanceWalkedOnStepModified + (double)MathHelper.sqrt_double(d15 * d15 + d16 * d16 + d17 * d17) * 0.6D);
//
//          if (this.distanceWalkedOnStepModified > (float)this.nextStepDistance && block1.getMaterial() != Material.air)
//          {
//            this.nextStepDistance = (int)this.distanceWalkedOnStepModified + 1;
//
//            if (this.isInWater())
//            {
//              float f = MathHelper.sqrt_double(this.motionX * this.motionX * 0.20000000298023224D + this.motionY * this.motionY + this.motionZ * this.motionZ * 0.20000000298023224D) * 0.35F;
//
//              if (f > 1.0F)
//              {
//                f = 1.0F;
//              }
//
//              this.playSound(this.getSwimSound(), f, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
//            }
//
//            this.playStepSound(blockpos, block1);
//          }
//        }
//
//        try
//        {
//          this.doBlockCollisions();
//        }
//        catch (Throwable throwable)
//        {
//          CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Checking entity block collision");
//          CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being checked for collision");
//          this.addEntityCrashInfo(crashreportcategory);
//          throw new ReportedException(crashreport);
//        }
//
//        boolean flag2 = this.isWet();
//
//        if (this.worldObj.func_147470_e(this.getEntityBoundingBox().contract(0.001D, 0.001D, 0.001D)))
//        {
//          this.dealFireDamage(1);
//
//          if (!flag2)
//          {
//            ++this.fire;
//
//            if (this.fire == 0)
//            {
//              this.setFire(8);
//            }
//          }
//        }
//        else if (this.fire <= 0)
//        {
//          this.fire = -this.fireResistance;
//        }
//
//        if (flag2 && this.fire > 0)
//        {
//          this.playSound("random.fizz", 0.7F, 1.6F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
//          this.fire = -this.fireResistance;
//        }
//
//        this.worldObj.theProfiler.endSection();
//      }
//    }
//
//  }
//
//
//  private HashSet<BlockPos>;
//  private HashSet<Integer>;
//
//  private LinkedList<BreathNode> breathNode;
//
//
//
//}
