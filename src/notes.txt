outstanding bugs
- tick handlers
- bone for sit doesn't work.

-HOME for AI?

DataWatcher usage:
Entity
0 = STATUS byte = 0
   Known flags: 0) is burning; 1) is sneaking; 2) is riding something; 3) is sprinting; 4) is eating
1 = AIR short = 300 amount of air / breath
2 = CUSTOM NAME TAG string = ""
3 = ALWAYS RENDER NAME TAG byte = 0
4 = SILENT byte = 0, 1 = silent

EntityLivingBase
6 = HEALTH float = 60.0
7 = int = 0  Affected by a potion, contains the colour of the effect
8 = byte = 0  EnumParticleTypes.SPELL_MOB_AMBIENT vs EnumParticleTypes.SPELL_MOB  - beacon effects vs other effects?
9 = byte = 0  Number of arrows stuck in entity

EntityAgeable
12 = JUVENILE/ADULT flag byte = -1

EntityLiving
15 = AI enable/disable byte = 0

EntityTameable
16 = TAMED_FLAGS byte = 0;
     4 = tamed?
     1 = sitting?
17 = OWNER_ID string = ""

DragonMounts
18 = INDEX_FLYING byte = 0
19 = INDEX_CAN_FLY byte = 0
20 = INDEX_SADDLED byte = 0
21 = INDEX_BREEDER string = "Player63"
22 = INDEX_BREED string = "ghost"
23 = INDEX_REPRO_COUNT integer = 0
24 = INDEX_TICKS_SINCE_CREATION short

breath weapons
fire
lightning
fireballs
ice/snow

thoughts-
could use an entityemitter with breath aiming info
or alternatively just packets (server sends regular updates on breath beam position to clients)
or - always use dragon head pos, pitch, & yaw (or aim point) for beam origin rendering?

spawn EntityFX as per vanilla?  or just use custom rendering based on breath beam?

packet might be
timestamp (byte)
entityID
origin [x,y,z] in packed format, 2 bytes per axis (say - lsb is the fractional position, msb is the world position, snap to
   entity position)
yaw and pitch, both as short
Datawatcher instead?

smooth out any jerks in aiming position?

Want it to look best from the client who is controlling the dragon
-Will be best to tie the origin to the dragon's head always, also the aim.  Collision checks on client for rendering
--> send to the server where the player thinks the beam is starting & aiming
--> server performs sanity check but otherwise trusts the client information.  Does collision checks etc itself
--> server sends to other clients in step with entity info.  client renders with beam bound to head, uses aiming direction from
    server.

On client side: spawn EntityFX
On server side: dragonentity keeps track of the breath location over time- eg each tick adds another sphere coordinate
  to a list, updates position of all, tracks them until they die.  Create a list of all touched blocks, for each one which
  is a block, burn it.  Sustained contact for a long time does smelting (eg sand to glass).  Other breaths do other
  effects, eg freezing to break blocks, skeletal dragon kills living things (turns to dead bush?) etc.

------------------
need head position
Each model part has:
  rotationPointX, Y, Z and rotateAngleX Y Z
  offsetX, Y, Z



head: rotPtX = 0, rotPtY = -2.389, rotPtZ = -34.9967
